// Generated by CoffeeScript 1.9.1
(function() {
  var DB, OMgr, ResolveModule, SuperModel, all, debug, defer, dirname, error, resolver, uuid,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  defer = require('node-promise').defer;

  all = require('node-promise').allOrNone;

  uuid = require('node-uuid');

  OMgr = require('./OStore');

  DB = require('./DB');

  error = require('./Error').error;

  ResolveModule = require('./ResolveModule');

  console.log('supermodel dirname is ' + __dirname);

  console.log(__dirname);

  dirname = __dirname.substring(0, __dirname.indexOf('/node_modules'));

  if (__dirname.indexOf('node_modules') === -1) {
    dirname = '../..';
  }

  console.log('starting module resolving from path ' + dirname);

  resolver = new ResolveModule(dirname);

  debug = process.env["DEBUG"];

  SuperModel = (function() {
    SuperModel.resolver = resolver;

    SuperModel.prototype._getRecord = function() {
      var rv;
      rv = this.getRecord();
      rv._rev = this._rev;
      return rv;
    };

    function SuperModel(record1) {
      var q;
      this.record = record1 != null ? record1 : {};
      this.insertObj = bind(this.insertObj, this);
      this.loadFromIds = bind(this.loadFromIds, this);
      this.serialize = bind(this.serialize, this);
      this.toClient = bind(this.toClient, this);
      this.getRecord = bind(this.getRecord, this);
      this._getRecord = bind(this._getRecord, this);
      q = defer();
      this.id = this.record.id || uuid.v4();
      OMgr.storeObject(this);
      if (this.record._rev) {
        if (debug) {
          console.log('setting _rev to ' + this.record._rev + ' for ' + this.constructor.type + ' ' + this.id);
        }
        this._rev = this.record._rev;
      }
      this.loadFromIds(this.constructor.model).then((function(_this) {
        return function() {
          if (_this.postCreate) {
            return _this.postCreate(q);
          } else {
            return q.resolve(_this);
          }
        };
      })(this), error);
      if (debug) {
        console.log('returning promise from constructor for ' + this.constructor.type);
      }
      return q;
    }

    SuperModel.prototype.getRecord = function() {
      return this._getRecord(this, this.constructor.model, this.record);
    };

    SuperModel.prototype._getRecord = function(me, model, record) {
      var rv;
      rv = {};
      if (!model) {
        console.dir(me);
      }
      model.forEach(function(v) {
        var hk, hv, k, ref, varr;
        k = v.name;
        if (v.value) {
          return rv[k] = me[v.value] || record[k];
        } else if (v.hashtable) {
          varr = [];
          ref = me[v.name];
          for (hk in ref) {
            hv = ref[hk];
            varr.push(hv.id);
          }
          return rv[k] = varr;
        } else if (v.array) {
          varr = [];
          me[v.name].forEach(function(hv) {
            return varr.push(hv.id);
          });
          return rv[k] = varr;
        } else {
          if (debug) {
            console.log('getRecord accessing property ' + k + ' of object ' + this.constructor.type + ' -> ' + me[k]);
          }
          return rv[k] = me[k].id;
        }
      });
      rv.id = this.id;
      rv.type = this.constructor.type;
      return rv;
    };

    SuperModel.prototype.toClient = function() {
      var k, r, ra, rv, v;
      r = this.getRecord();
      ra = this.constructor.model;
      rv = {};
      for (k in r) {
        v = r[k];
        ra.forEach(function(el) {
          if (el.name === k && el["public"]) {
            return rv[k] = v;
          }
        });
      }
      rv.id = this.id;
      rv.type = this.constructor.type;
      return rv;
    };

    SuperModel.prototype.serialize = function() {
      var q, record;
      q = defer();
      if (!this._serializing) {
        this._serializing = true;
        record = this.getRecord();
        if (this._rev) {
          record._rev = this._rev;
        }
        OMgr.storeObject(this);
        DB.set(this.constructor.type, record).then((function(_this) {
          return function() {
            _this._serializing = false;
            return q.resolve(_this);
          };
        })(this));
      } else {
        q.resolve(this);
      }
      return q;
    };

    SuperModel.prototype.loadFromIds = function(model) {
      var alldone, allpromises, q;
      if (debug) {
        console.log('------------------------------------------------> loadfromIds called for ' + this.constructor.type + ' ' + this.id + ' ' + model.length + ' properties');
      }
      if (debug) {
        console.dir(model);
      }
      if (debug) {
        console.log('record is...');
      }
      if (debug) {
        console.dir(this.record);
      }
      alldone = defer();
      allpromises = [];
      if (!model || model.length === 0) {
        console.log(' ++++++++++++++++ NO model ++++++++++++++');
        q = defer();
        allpromises.push(q);
        q.resolve();
      } else {
        model.forEach((function(_this) {
          return function(robj) {
            return (function(resolveobj) {
              var count, ids, r;
              r = defer();
              allpromises.push(r);
              if (resolveobj.value) {
                _this[resolveobj.name] = _this.record[resolveobj.value] || resolveobj["default"];
              }
              if (resolveobj.array === true) {
                _this[resolveobj.name] = [];
              }
              if (resolveobj.hashtable === true) {
                _this[resolveobj.name] = {};
              }
              ids = _this.record[resolveobj.ids];
              if (!ids || typeof ids === 'undefined' || ids === 'undefined') {
                ids = [];
                if (debug) {
                  console.log('============================== null resolveobj.ids for ' + resolveobj.type + ' [' + resolveobj.name + ']');
                }
                return r.resolve(null);
              } else {
                if (typeof ids === 'string') {
                  ids = [ids];
                }
                if (debug) {
                  console.log('resolveobjds ' + resolveobj.name + ' (' + (typeof ids) + ') ids length are.. ' + ids.length);
                }
                count = ids.length;
                if (count === 0) {
                  if (debug) {
                    console.log('no ids for ' + resolveobj.name + ' so resolving null');
                  }
                  return r.resolve(null);
                } else {
                  return ids.forEach(function(id) {
                    if (debug) {
                      console.log('trying to get ' + resolveobj.name + ' with id ' + id);
                    }
                    return OMgr.getObject(id, resolveobj.type).then(function(oo) {
                      if (oo) {
                        if (debug) {
                          console.log('found existing instance of ' + resolveobj.name + ' type ' + resolveobj.type + ' in OStore');
                        }
                        _this.insertObj(resolveobj, oo);
                        if (--count === 0) {
                          if (debug) {
                            console.log('resolving ' + resolveobj.name + ' type ' + resolveobj.type + ' immediately');
                          }
                          return r.resolve(oo);
                        }
                      } else {
                        if (debug) {
                          console.log('did not find obj ' + resolveobj.name + ' of type ' + resolveobj.type + ' in OStore. Getting from DB...');
                        }
                        return DB.get(resolveobj.type, [id]).then(function(record) {
                          return resolver.createObjectFrom(record).then(function(obj) {
                            if (debug) {
                              console.log('object ' + resolveobj.name + ' type ' + resolveobj.type + ' created: ' + obj.id);
                            }
                            _this.insertObj(resolveobj, obj);
                            if (--count === 0) {
                              return r.resolve(obj);
                            }
                          }, error);
                        }, error);
                      }
                    }, error);
                  });
                }
              }
            })(robj);
          };
        })(this));
      }
      all(allpromises, error).then((function(_this) {
        return function(results) {
          if (debug) {
            console.log('<------------------------------------------------ loadfromIds done for ' + _this.constructor.type + ' ' + _this.id + ' ' + model.length + ' properties');
          }
          return alldone.resolve(results);
        };
      })(this), error);
      return alldone;
    };

    SuperModel.prototype.insertObj = function(ro, o) {
      if (ro.array === true) {
        if (debug) {
          console.log('inserting obj ' + ro.type + ' as array');
        }
        this[ro.name].push(o);
      } else if (ro.hashtable === true) {
        if (debug) {
          console.log('inserting obj ' + ro.type + ' as hashtable');
        }
        this[ro.name][o.name] = o;
      } else {
        if (debug) {
          console.log('inserting obj ' + ro.type + ' as direct reference');
        }
        this[ro.name] = o;
      }
      return OMgr.storeObject(o);
    };

    return SuperModel;

  })();

  module.exports = SuperModel;

}).call(this);

//# sourceMappingURL=SuperModel.js.map
