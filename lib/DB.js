// Generated by CoffeeScript 1.9.3
(function() {
  var Couch, DB, Google, LRU, Mongo, OStore, ResolveModule, Rethink, all, debug, defer, resolver, uuid;

  defer = require('node-promise').defer;

  all = require('node-promise').all;

  uuid = require('node-uuid');

  LRU = require('lru-cache');

  OStore = require('./OStore');

  Couch = require('./CouchPersistence');

  Mongo = require('./MongoPersistence');

  Rethink = require('./RethinkPersistence');

  Google = require('./GooglePersistence');

  ResolveModule = require('./ResolveModule');

  resolver = new ResolveModule();

  debug = process.env["DEBUG"];

  DB = (function() {
    function DB() {}

    DB.dburl = 'localhost';

    DB.lru = LRU();

    DB.lrudiff = LRU();

    DB.dbname = '';

    DB.onUpdated = function(record) {
      return resolver.createObjectFrom(record).then(function(ooo) {
        return OStore.updateObj(ooo);
      });
    };

    DB.getDataStore = function(_name) {
      var name, q;
      name = _name || DB.dbname;
      DB.dbname = name;
      q = defer();
      if (!DB.DataStore) {
        if (!name) {
          DB.DataStore = new Rethink(DB.dburl, DB);
        } else if (name === 'couchdb') {
          DB.DataStore = new Couch(DB.dburl);
        } else if (name === 'mongodb') {
          DB.DataStore = new Mongo(DB.dburl, DB);
        } else if (name === 'rethinkdb') {
          DB.DataStore = new Rethink(DB.dburl, DB);
        } else if (name === 'google') {
          DB.DataStore = new Google(DB.dburl, DB);
        }
        DB.DataStore.connect().then(function(ds) {
          DB.DataStore = ds;
          console.log('DB got back datastore for ' + name);
          return q.resolve(ds);
        });
      } else {
        q.resolve(DB.DataStore);
      }
      return q;
    };

    DB.createDatabases = function(dblist) {
      var q;
      q = defer();
      console.log('*** createDatabases called for list of dbs...');
      console.dir(dblist);
      DB.getDataStore().then(function(store) {
        var promises;
        console.log('DB.createDatabases got back store');
        promises = [];
        dblist.forEach(function(dbname) {
          var db;
          console.log('attempting to get table for ' + dbname);
          db = store.getDbFor(dbname);
          return promises.push(db);
        });
        return all(promises).then(function(results) {
          console.log('*DB.createDatabases all good');
          dblist.forEach(function(dbname2) {
            return DB.extendSchemaIfNeeded(DB.DataStore, dbname2);
          });
          return q.resolve(results);
        });
      });
      return q;
    };

    DB.extendSchemaIfNeeded = function(db, _dbname) {
      var dbname, k, proto, q, ref, v;
      dbname = _dbname;
      q = defer();
      console.log('* extendSchemaIfNeeded for module "' + _dbname + '"we have the following modules named in cache:');
      ref = ResolveModule.modulecache;
      for (k in ref) {
        v = ref[k];
        console.log(k);
      }
      proto = ResolveModule.modulecache[dbname];
      console.log('extendSchemaIfNeeded resolve ' + dbname + ' to ' + proto);
      if (!proto) {
        console.log('found undefined prototype!. modulecache is');
      }
      db.all(dbname, {}, function(res) {
        var count, lookup, missing, o;
        console.log('extendSchemaIfNeeded found ' + res.length + ' objects after call to all()');
        o = res[0];
        missing = [];
        lookup = {
          createdAt: true,
          modifiedAt: true,
          createdBy: true
        };
        for (k in o) {
          v = o[k];
          lookup[k] = k;
        }
        proto.model.forEach(function(property) {
          if (!lookup[property.name]) {
            return missing.push(property);
          }
        });
        console.log('found ' + missing.length + ' missing properties on first object compared to current model : ');
        console.dir(missing);
        if (missing.length > 0) {
          count = res.length * missing.length;
          console.log('adding ' + missing.length + ' missing properties to ' + res.length + ' existing objects');
          return res.forEach(function(ro) {
            return missing.forEach(function(mprop) {
              if (!mprop["default"]) {
                if (mprop.array) {
                  mprop["default"] = [];
                } else if (mprop.hashtable) {
                  mprop["default"] = {};
                } else if (mprop.type) {
                  mprop["default"] = '-1';
                }
              }
              return DB.extend(ro.type, ro.id, mprop.name, mprop["default"]).then(function(o) {
                DB.lru.set(o.id, o);
                if (--count === 0) {
                  console.log('extendSchemaIfNeeded done for ' + res.length + ' objects');
                  return q.resolve();
                }
              });
            });
          });
        } else {
          return q.resolve();
        }
      });
      return q;
    };

    DB.extend = function(type, id, field, def) {
      return DB.getDataStore().then(function(store) {
        console.log('extending ' + type + ' id ' + id + ' with new property ' + field + ' and default value of ' + def);
        return store.extend(type, id, field, def);
      });
    };

    DB.getFromStoreOrDB = function(type, id) {
      var q;
      q = defer();
      OStore.getObject(id, type).then(function(oo) {
        if (oo) {
          return q.resolve(oo);
        } else {
          return DB.get(type, [id]).then(function(records) {
            var record;
            if (records && records[0]) {
              record = records[0];
              return resolver.createObjectFrom(record).then(function(ooo) {
                return q.resolve(ooo);
              });
            } else {
              return q.resolve(void 0);
            }
          });
        }
      });
      return q;
    };

    DB.getOrCreateObjectByRecord = function(record) {
      var q;
      q = defer();
      OStore.getObject(record.id, record.type).then(function(oo) {
        if (debug) {
          console.log('DB.getOrCreateObjectByRecord OStore returns ' + oo);
        }
        if (oo) {
          return q.resolve(oo);
        } else {
          return DB.get(record.type, [record.id]).then(function(res) {
            if (debug) {
              console.log('DB.getOrCreateObjectByRecord DB load returns ' + res);
            }
            if (res && res[0]) {
              if (debug) {
                console.log('DB.getOrCreateObjectByRecord found existing record in DB *');
              }
              record = res[0];
            }
            return resolver.createObjectFrom(record).then(function(ooo) {
              if (debug) {
                console.log('DB.getOrCreateObjectByRecord createFromRecord returns ' + ooo);
              }
              return q.resolve(ooo);
            });
          });
        }
      });
      return q;
    };

    DB.byProviderId = function(type, pid) {
      var q;
      q = defer();
      if (pid) {
        DB.getDataStore().then(function(store) {
          return store.byProviderId(type, pid).then(function(res) {
            return q.resolve(res);
          });
        });
      } else {
        q.resolve(void 0);
      }
      return q;
    };

    DB.all = function(type, query, cb) {
      return DB.getDataStore().then(function(store) {
        if (store.all) {
          return store.all(type, query, cb);
        } else {
          console.log('DB.all: All not implemented in underlying persistence logic');
          return cb([]);
        }
      });
    };

    DB.count = function(type) {
      var q;
      q = defer();
      DB.getDataStore().then(function(store) {
        return store.count(type).then(function(value) {
          return q.resolve(value);
        });
      });
      return q;
    };

    DB.find = function(type, property, value) {
      var q;
      q = defer();
      DB.getDataStore().then(function(store) {
        return store.find(type, property, value).then(function(result) {
          if (!result) {
            console.log('DB.find type ' + type + ', property ' + property + ', value ' + value + ' got back ' + result);
          } else {
            DB.lru.set(result.id, result);
          }
          return q.resolve(result);
        });
      });
      return q;
    };

    DB.findMany = function(type, property, value) {
      var q;
      q = defer();
      DB.getDataStore().then(function(store) {
        return store.findMany(type, property, value).then(function(results) {
          if (!results || !results.length) {
            console.log('DB.findMany type ' + type + ', property ' + property + ', value ' + value + ' got back ' + results);
            return q.resolve([]);
          } else {
            results.forEach(function(result) {
              return DB.lru.set(result.id, result);
            });
            return q.resolve(results);
          }
        });
      });
      return q;
    };

    DB.findQuery = function(type, query) {
      var q;
      q = defer();
      DB.getDataStore().then(function(store) {
        return store.findQuery(type, query).then(function(results) {
          if (results && results.length && results.length > 0) {
            results.forEach(function(result) {
              if (result) {
                return DB.lru.set(result.id, result);
              }
            });
          }
          return q.resolve(results);
        });
      });
      return q;
    };

    DB.search = function(type, property, value) {
      var q;
      q = defer();
      DB.getDataStore().then(function(store) {
        return store.search(type, property, value).then(function(results) {
          if (!results) {
            console.log('DB.search type ' + type + ', property ' + property + ', value ' + value + ' got back ' + results);
          } else {
            results.forEach(function(result) {
              return DB.lru.set(result.id, result);
            });
          }
          return q.resolve(results);
        });
      });
      return q;
    };

    DB.get = function(type, ids) {
      var id, q, rv;
      if (debug) {
        console.log('DB.get called for type "' + type + '" and ids "' + ids + '"');
      }
      if (!ids.length) {
        ids = [ids];
      }
      q = defer();
      id = ids[0];
      if (typeof id === 'object') {
        console.log('DB.get was served an object instead of an id!!!');
        console.dir(id);
        q.resolve(null);
      } else {
        rv = DB.lru.get(id);
        console.log('DB found ' + id + '  in lru: ' + rv);
        console.dir(rv);
        if (rv) {
          q.resolve([rv]);
        } else {
          DB.getDataStore().then(function(store) {
            return store.get(type, id, function(result) {
              if (!result) {
                if (debug) {
                  console.log('DB.get for type ' + type + ' and id ' + id + ' got back ' + result);
                  console.dir(result);
                }
              } else {
                DB.lru.set(id, result);
              }
              return q.resolve([result]);
            });
          });
        }
      }
      return q;
    };

    DB.set = function(type, obj, cb) {
      if (obj) {
        DB.lru.set(obj.id, obj);
        return DB.getDataStore().then(function(store) {
          return store.set(type, obj, function(res) {
            if (debug) {
              console.log('DB.set got back ' + res);
            }
            return cb(res);
          });
        });
      } else {
        return cb();
      }
    };

    DB.remove = function(obj, cb) {
      DB.lru.del(obj.id);
      return DB.getDataStore().then(function(store) {
        return store.remove(obj.type, obj, function(res) {
          if (cb) {
            return cb(res);
          }
        });
      });
    };

    return DB;

  })();

  module.exports = DB;

}).call(this);

//# sourceMappingURL=DB.js.map
