// Generated by CoffeeScript 1.8.0
(function() {
  var Couch, DB, LRU, Mongo, OStore, all, debug, defer, uuid;

  defer = require('node-promise').defer;

  all = require('node-promise').all;

  uuid = require('node-uuid');

  LRU = require('lru-cache');

  OStore = require('.Ostore');

  Couch = require('./CouchPersistence');

  Mongo = require('./MongoPersistence');

  debug = process.env["DEBUG"];

  DB = (function() {
    function DB() {}

    DB.lru = LRU();

    DB.lrudiff = LRU();

    DB.getDataStore = function(name) {
      if (!DB.DataStore) {
        if (!name) {
          DB.DataStore = new Mongo();
        } else if (name === 'couchdb') {
          DB.DataStore = new Couch();
        } else if (name === 'mogodbdb') {
          DB.DataStore = new Mongo();
        }
        DB.DataStore.connect();
      }
      return DB.DataStore;
    };

    DB.createDatabases = function(dblist) {
      var promises, q, store;
      store = DB.getDataStore();
      q = defer();
      promises = [];
      dblist.forEach(function(dbname) {
        var obj;
        if (debug) {
          console.log('attempting to get store for ' + dbname);
        }
        obj = {
          id: 'all_' + DB.constructor.type,
          list: [DB.id],
          getRecord: function() {
            return {
              id: obj.id,
              list: obj.list
            };
          }
        };
        OStore.storeObject(obj);
        return promises.push(store.getDbFor(dbname));
      });
      all(promises).then(function(results) {
        return q.resolve(results);
      });
      return q;
    };

    DB.byProviderId = function(type, pid) {
      var q, store;
      q = defer();
      store = DB.getDataStore();
      store.byProviderId(type, pid).then(function(res) {
        return q.resolve(res);
      });
      return q;
    };

    DB.all = function(type, cb) {
      var store;
      store = DB.getDataStore();
      if (store.all) {
        return store.all(type, cb);
      } else {
        console.log('DB.all: All not implemented in underlying persistence logic');
        return cb([]);
      }
    };

    DB.get = function(type, ids) {
      var q;
      if (!ids.length) {
        ids = [ids];
      }
      q = defer();
      all(ids.map(function(id) {
        var p, rv;
        rv = DB.lru.get(id);
        p = defer();
        if (!rv) {
          DB.getDataStore().get(type, id, function(result) {
            if (!result) {
              console.log('DB.get for type ' + type + ' got back ' + result);
            }
            DB.lru.set(id, result);
            return p.resolve(result);
          });
        } else {
          p.resolve(rv);
        }
        return p;
      })).then(function(result) {
        return q.resolve(result);
      }, function(err) {
        console.log('DB.get ERROR: ' + err);
        console.dir(err);
        return q.resolve(null);
      });
      return q;
    };

    DB.set = function(type, obj, cb) {
      DB.lru.set(obj.id, obj);
      return DB.getDataStore().set(type, obj, function(res) {
        if (cb) {
          return cb();
        }
      });
    };

    DB.remove = function(obj, cb) {
      DB.lru.del(obj.id);
      return DB.getDataStore().remove(obj.type, obj, function(res) {
        if (cb) {
          return cb(res);
        }
      });
    };

    return DB;

  })();

  module.exports = DB;

}).call(this);

//# sourceMappingURL=DB.js.map
