// Generated by CoffeeScript 1.8.0
(function() {
  var Db, MongoClient, MongoPersistence, MongoWatch, Server, cursor, debug, defer, oplog,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Db = require('mongodb').Db;

  Server = require('mongodb').Server;

  MongoClient = require('mongodb').MongoClient;

  defer = require('node-promise').defer;

  MongoWatch = require('mongo-watch');

  debug = process.env["DEBUG"];

  oplog = void 0;

  cursor = void 0;

  MongoPersistence = (function() {
    var madr, mport, watcher;

    if (process.env['MONGODB_PORT_27017_TCP_PORT']) {
      madr = 'mongodb';
    } else {
      madr = '127.0.0.1';
    }

    mport = process.env['MONGODB_PORT_27017_TCP_PORT'] || '27017';

    if (debug) {
      console.log('mongodb adr = ' + madr + ', port = ' + mport);
    }

    watcher = void 0;

    function MongoPersistence(dburl) {
      this.dburl = dburl;
      this.remove = __bind(this.remove, this);
      this.set = __bind(this.set, this);
      this.search = __bind(this.search, this);
      this.findQuery = __bind(this.findQuery, this);
      this.findMany = __bind(this.findMany, this);
      this.find = __bind(this.find, this);
      this.byProviderId = __bind(this.byProviderId, this);
      this.get = __bind(this.get, this);
      this.count = __bind(this.count, this);
      this.all = __bind(this.all, this);
      this.getDbFor = __bind(this.getDbFor, this);
      this.foo = __bind(this.foo, this);
      this.getConnection = __bind(this.getConnection, this);
      this.connect = __bind(this.connect, this);
      if (this.dburl) {
        madr = this.dburl;
      }
      this.dbs = [];
    }

    MongoPersistence.prototype.connect = function() {
      return console.log('Mongo connect called');
    };

    MongoPersistence.prototype.getConnection = function() {
      var q;
      q = defer();
      if (this.db) {
        q.resolve(this.db);
      } else {
        this.foo(q);
      }
      return q;
    };

    MongoPersistence.prototype.foo = function(q) {
      var cstring, repls, rs;
      cstring = 'mongodb://' + madr + ':' + mport + '/spincycle';
      repls = process.env['MONGODB_REPLS'];
      rs = process.env['MONGODB_RS'];
      if (repls) {
        cstring = 'mongodb://' + repls + '/spincycle?replicaSet=' + rs;
        if (debug) {
          console.log('Mongo driver cstring is ' + cstring);
        }
        return MongoClient.connect(cstring, {
          fsync: true,
          slave_ok: true,
          replSet: {
            replicaSet: rs,
            connectWithNoPrimary: true
          }
        }, (function(_this) {
          return function(err, db) {
            var rarr;
            if (err) {
              console.log('MONGO Error connecting to "' + cstring + '" ' + err);
              console.dir(err);
              console.log('retrying.....');
              return setTimeout(function() {
                return _this.foo(q);
              }, 2000);
            } else {
              console.log("---- We are connected ---- *");
              _this.db = db;
              rarr = repls.split(",");
              rarr.forEach(function(repl) {
                var parts;
                parts = repl.split(":");
                return rs.push({
                  host: parts[0],
                  port: parts[1]
                });
              });
              console.log('watcher replicas ---->');
              console.dir(rs);
              watcher = new MongoWatch({
                replicaSet: rs,
                format: 'pretty'
              });
              return q.resolve(db);
            }
          };
        })(this));
      } else {
        if (debug) {
          console.log('Mongo driver cstring is ' + cstring);
        }
        return MongoClient.connect(cstring, {
          fsync: true,
          slave_ok: true
        }, (function(_this) {
          return function(err, db) {
            if (err) {
              console.log('MONGO Error connecting to "' + cstring + '" ' + err);
              console.dir(err);
              console.log('retrying.....');
              return setTimeout(function() {
                return _this.foo(q);
              }, 2000);
            } else {
              console.log("---- We are connected ----");
              _this.db = db;
              return q.resolve(db);
            }
          };
        })(this));
      }
    };

    MongoPersistence.prototype.getDbFor = function(_type) {
      var db, q, type;
      q = defer();
      type = _type.toLowerCase();
      db = this.dbs[type];
      if (!db) {
        this.getConnection().then((function(_this) {
          return function(connection) {
            return connection.collection(type, function(err, ndb) {
              if (err) {
                console.log('MONGO Error getting collection: ' + err);
                console.dir(err);
                return q.resolve(null);
              } else {
                _this.dbs[type] = ndb;
                watcher.watch('spincycle.' + type, function(event) {
                  return console.log('something changed in collection ' + type + ':', event);
                });
                return q.resolve(ndb);
              }
            });
          };
        })(this));
      } else {
        q.resolve(db);
      }
      return q;
    };

    MongoPersistence.prototype.all = function(_type, cb) {
      var type;
      if (debug) {
        console.log('Mongo::all called for type ' + _type);
      }
      type = _type.toLowerCase();
      return this.getDbFor(type).then((function(_this) {
        return function(collection) {
          if (collection) {
            if (debug) {
              console.log('Mongo.all collection is ' + collection);
            }
            return collection.find({}, function(err, res) {
              return res.toArray(function(err, items) {
                if (err) {
                  console.log('MONGO Error getting all: ' + err);
                  console.dir(err);
                  return cb(null);
                } else {
                  return cb(items);
                }
              });
            });
          } else {
            return cb(null);
          }
        };
      })(this));
    };

    MongoPersistence.prototype.count = function(_type) {
      var q, type;
      if (debug) {
        console.log('Mongo::count called for type ' + _type);
      }
      type = _type.toLowerCase();
      q = defer();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          if (collection) {
            return collection.count({}, function(err, count) {
              if (err) {
                console.log('MONGO count Error: ' + err);
                console.dir(err);
                return cb(-1);
              } else {
                return q.resolve(count);
              }
            });
          } else {
            console.log('!!!!! Mongo.count could not get collection!!!!!!!!  ' + collection);
            return cb(-1.);
          }
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.get = function(_type, id, cb) {
      var type;
      type = _type.toLowerCase();
      if (typeof id === 'object') {
        console.log('Mongo.get got an object as id instead of string !!!!! ');
        cb(null);
      }
      return this.getDbFor(type).then((function(_this) {
        return function(collection) {
          return collection.findOne({
            id: id
          }, function(err, item) {
            if (err) {
              console.log('MONGO get Error: ' + err);
              console.dir(err);
              return cb(null);
            } else {
              return cb(item);
            }
          });
        };
      })(this));
    };

    MongoPersistence.prototype.byProviderId = function(_type, pid) {
      var q, type;
      console.log('byProviderId called for pid ' + pid + ' and type ' + _type);
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          return collection.findOne({
            providerId: pid
          }, function(err, item) {
            if (err) {
              console.log('MONGO byProviderId Error: ' + err);
              console.dir(err);
              return q.resolve(null);
            } else {
              if (debug) {
                console.log('Mongo byProviderId for ' + pid + ' got back');
              }
              if (debug) {
                console.dir(item);
              }
              return q.resolve(item);
            }
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.find = function(_type, property, value) {
      var q, type;
      if (debug) {
        console.log('Mongo find called for type ' + _type + ' property ' + property + ' and value ' + value);
      }
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          var query;
          query = {};
          query[property] = value;
          if (debug) {
            console.log('query is ');
          }
          if (debug) {
            console.dir(query);
          }
          return collection.findOne(query, function(err, item) {
            if (err) {
              console.log('MONGO find Error: ' + err);
              console.dir(err);
              return q.resolve(null);
            } else if (!item[property] === value) {
              return q.resolve(null);
            } else {
              if (debug) {
                console.log('find result is ');
              }
              if (debug) {
                console.dir(item);
              }
              return q.resolve(item);
            }
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.findMany = function(_type, property, value) {
      var q, type;
      if (debug) {
        console.log('Mongo findmany called for type ' + _type + ' property ' + property + ' and value ' + value);
      }
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          var query;
          query = {};
          query[property] = value;
          if (debug) {
            console.log('query is ');
          }
          if (debug) {
            console.dir(query);
          }
          return collection.find(query).toArray(function(err, docs) {
            var arr;
            arr = docs;
            if (debug) {
              console.log('findMany returns ' + arr.length + ' items');
            }
            return q.resolve(arr);
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.findQuery = function(_type, query) {
      var q, type;
      console.log('Mongo findQuery called for type ' + _type + ' property ' + property + ' and value ' + value);
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          var options;
          q = {};
          if (query.wildcard) {
            q[property] = {
              $regex: '^' + value
            };
          } else {
            q[query.property] = query.value;
          }
          options = {};
          if (query.limit) {
            options.limit = query.limit;
          }
          if (query.skip) {
            options.skip = query.skip;
          }
          if (query.sort) {
            options.limit = query.sort;
          }
          if (debug) {
            console.log('query is ');
          }
          if (debug) {
            console.dir(query);
          }
          return collection.find(query, options, function(err, cursor) {
            var arr;
            if (err) {
              console.log('MONGO findQuery Error: ' + err);
              console.dir(err);
              return q.resolve(null);
            } else {
              arr = cursor.toArray();
              if (debug) {
                console.log('findQuery returns ' + arr.length + ' items');
              }
              return q.resolve(arr);
            }
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.search = function(_type, property, value) {
      var q, type;
      console.log('Mongo search called for type ' + _type + ' property ' + property + ' and value ' + value);
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          var query;
          query = {};
          query[property] = {
            $regex: '^' + value
          };
          if (debug) {
            console.log('mongo find query is');
          }
          if (debug) {
            console.dir(query);
          }
          return collection.find(query, function(err, items) {
            if (err) {
              console.log('MONGO search Error: ' + err);
              console.dir(err);
              return q.resolve(null);
            } else {
              return items.toArray(function(err2, docs) {
                if (err2) {
                  console.log('MONGO search toArray Error: ' + err2);
                  return console.dir(err2);
                } else {
                  return q.resolve(docs);
                }
              });
            }
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.set = function(_type, obj, cb) {
      var type;
      type = _type.toLowerCase();
      return this.getDbFor(type).then((function(_this) {
        return function(collection) {
          if (typeof obj.id === 'object') {
            console.dir(obj);
          }
          return collection.update({
            id: obj.id
          }, obj, {
            upsert: true
          }, function(err, result, details) {
            if (err) {
              console.log('MONGO set Error: ' + err);
              console.dir(err);
              return cb(null);
            } else {
              return cb(result);
            }
          });
        };
      })(this));
    };

    MongoPersistence.prototype.remove = function(_type, obj, cb) {
      var type;
      type = _type.toLowerCase();
      return this.getDbFor(type).then((function(_this) {
        return function(collection) {
          return collection.remove({
            id: obj.id
          }, {
            w: 1
          }, function(err, numberOfRemovedDocs) {
            if (err) {
              console.log('MONGO remove Error: ' + err);
              console.dir(err);
              return cb(null);
            } else {
              return cb(obj);
            }
          });
        };
      })(this));
    };

    return MongoPersistence;

  })();

  module.exports = MongoPersistence;

}).call(this);

//# sourceMappingURL=MongoPersistence.js.map
