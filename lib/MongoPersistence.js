// Generated by CoffeeScript 1.8.0
(function() {
  var Db, MongoClient, MongoOplog, MongoPersistence, Server, cursor, debug, defer, oplog,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Db = require('mongodb').Db;

  Server = require('mongodb').Server;

  MongoClient = require('mongodb').MongoClient;

  defer = require('node-promise').defer;

  MongoOplog = require('mongo-oplog');

  debug = process.env["DEBUG"];

  oplog = void 0;

  cursor = void 0;

  MongoPersistence = (function() {
    var madr, mport, watcher;

    if (process.env['MONGODB_PORT_27017_TCP_PORT']) {
      madr = 'mongodb';
    } else {
      madr = '127.0.0.1';
    }

    mport = process.env['MONGODB_PORT_27017_TCP_PORT'] || '27017';

    if (debug) {
      console.log('mongodb adr = ' + madr + ', port = ' + mport);
    }

    watcher = void 0;

    function MongoPersistence(dburl, DB) {
      this.dburl = dburl;
      this.DB = DB;
      this.remove = __bind(this.remove, this);
      this.set = __bind(this.set, this);
      this.search = __bind(this.search, this);
      this.findQuery = __bind(this.findQuery, this);
      this.findMany = __bind(this.findMany, this);
      this.find = __bind(this.find, this);
      this.byProviderId = __bind(this.byProviderId, this);
      this.get = __bind(this.get, this);
      this.count = __bind(this.count, this);
      this.all = __bind(this.all, this);
      this.getDbFor = __bind(this.getDbFor, this);
      this.foo = __bind(this.foo, this);
      this.getConnection = __bind(this.getConnection, this);
      this.connect = __bind(this.connect, this);
      this.dbs = [];
    }

    MongoPersistence.prototype.connect = function() {
      var q;
      q = defer();
      this.getConnection().then((function(_this) {
        return function() {
          console.log('-----Mongo initialized');
          return q.resolve(_this);
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.getConnection = function() {
      var q;
      q = defer();
      if (this.db) {
        q.resolve(this.db);
      } else {
        this.foo(q);
      }
      return q;
    };

    MongoPersistence.prototype.foo = function(q) {
      var repls, rs;
      this.cstring = 'mongodb://' + madr + ':' + mport + '/spincycle';
      repls = process.env['MONGODB_REPLS'];
      rs = process.env['MONGODB_RS'];
      if (repls) {
        this.cstring = 'mongodb://' + repls + '/spincycle?replicaSet=' + rs;
        if (debug) {
          console.log('Mongo driver cstring is ' + this.cstring);
        }
        return MongoClient.connect(this.cstring, {
          fsync: true,
          slave_ok: true,
          replSet: {
            replicaSet: rs,
            connectWithNoPrimary: true
          }
        }, (function(_this) {
          return function(err, db) {
            var rarr;
            if (err) {
              console.log('MONGO Error connecting to "' + _this.cstring + '" ' + err);
              console.dir(err);
              console.log('retrying.....');
              return setTimeout(function() {
                return _this.foo(q);
              }, 2000);
            } else {
              console.log("---- We are connected ----  *");
              _this.db = db;
              rs = [];
              rarr = repls.split(",");
              rarr.forEach(function(repl) {
                var parts;
                parts = repl.split(":");
                return rs.push({
                  host: parts[0],
                  port: parts[1]
                });
              });
              console.log('watcher replicas ---->');
              console.dir(rs);
              return q.resolve(db);
            }
          };
        })(this));
      } else {
        if (debug) {
          console.log('Mongo driver cstring is ' + this.cstring);
        }
        return MongoClient.connect(this.cstring, {
          fsync: true,
          slave_ok: true
        }, (function(_this) {
          return function(err, db) {
            if (err) {
              console.log('MONGO Error connecting to "' + _this.cstring + '" ' + err);
              console.dir(err);
              console.log('retrying.....');
              return setTimeout(function() {
                return _this.foo(q);
              }, 2000);
            } else {
              console.log("---- We are connected ----");
              _this.db = db;
              return q.resolve(db);
            }
          };
        })(this));
      }
    };

    MongoPersistence.prototype.getDbFor = function(_type) {
      var db, q, type;
      q = defer();
      type = _type.toLowerCase();
      db = this.dbs[type];
      if (!db) {
        this.getConnection().then((function(_this) {
          return function(connection) {
            return connection.collection(type, function(err, ndb) {
              var repls;
              if (err) {
                console.log('MONGO Error getting collection: ' + err);
                console.dir(err);
                return q.resolve(null);
              } else {
                _this.dbs[type] = ndb;
                repls = process.env['MONGODB_REPLS'];
                if (repls) {
                  oplog = MongoOplog('mongodb://' + repls + '/local', {
                    ns: 'spincycle.' + type
                  }).tail();
                  oplog.on('insert', function(doc) {
                    return console.log('insert ' + type + ' --> ' + doc.o._id);
                  });
                  oplog.on('update', function(doc) {
                    console.log('update ' + type + ' --> ' + doc.o.id);
                    return _this.DB.onUpdated(doc.o);
                  });
                  oplog.on('delete', function(doc) {
                    return console.log('delete ' + type + ' --> ' + doc.o._id);
                  });
                }
                return q.resolve(ndb);
              }
            });
          };
        })(this));
      } else {
        q.resolve(db);
      }
      return q;
    };

    MongoPersistence.prototype.all = function(_type, query, cb) {
      var type;
      if (debug) {
        console.log('Mongo::all called for type ' + _type);
      }
      type = _type.toLowerCase();
      return this.getDbFor(type).then((function(_this) {
        return function(collection) {
          if (collection) {
            if (debug) {
              console.log('Mongo.all collection is ' + collection);
            }
            return collection.find({}, function(err, res) {
              return res.toArray(function(err, items) {
                if (err) {
                  console.log('MONGO Error getting all: ' + err);
                  console.dir(err);
                  return cb(null);
                } else {
                  return cb(items);
                }
              });
            });
          } else {
            return cb(null);
          }
        };
      })(this));
    };

    MongoPersistence.prototype.count = function(_type) {
      var q, type;
      if (debug) {
        console.log('Mongo::count called for type ' + _type);
      }
      type = _type.toLowerCase();
      q = defer();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          if (collection) {
            return collection.count({}, function(err, count) {
              if (err) {
                console.log('MONGO count Error: ' + err);
                console.dir(err);
                return cb(-1);
              } else {
                return q.resolve(count);
              }
            });
          } else {
            console.log('!!!!! Mongo.count could not get collection!!!!!!!!  ' + collection);
            return cb(-1.);
          }
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.get = function(_type, id, cb) {
      var type;
      type = _type.toLowerCase();
      if (debug) {
        console.log('--------------------- Mongo.get called for type ' + type + ' and id ' + id);
      }
      if (typeof id === 'object') {
        console.log('Mongo.get got an object as id instead of string !!!!! ');
        console.dir(id);
        cb(null);
      }
      return this.getDbFor(type).then((function(_this) {
        return function(collection) {
          return collection.findOne({
            id: id
          }, function(err, item) {
            if (err) {
              console.log('MONGO get Error: ' + err);
              console.dir(err);
              return cb(null);
            } else {
              if (debug) {
                console.log('------ Mongo get found obejct');
              }
              if (debug) {
                console.dir(item);
              }
              return cb(item);
            }
          });
        };
      })(this));
    };

    MongoPersistence.prototype.byProviderId = function(_type, pid) {
      var q, type;
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          return collection.findOne({
            providerId: pid
          }, function(err, item) {
            if (err) {
              console.log('MONGO byProviderId Error: ' + err);
              console.dir(err);
              return q.resolve(null);
            } else {
              return q.resolve(item);
            }
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.find = function(_type, property, _value) {
      var q, type, value;
      value = _value || "";
      if (value) {
        value = value.toString();
      }
      if (debug) {
        console.log('Mongo find called for type ' + _type + ' property ' + property + ' and value ' + value);
      }
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          var query;
          query = {};
          query[property] = value;
          if (debug) {
            console.log('query is ');
          }
          if (debug) {
            console.dir(query);
          }
          return collection.findOne(query, function(err, item) {
            if (err) {
              console.log('MONGO find Error: ' + err);
              console.dir(err);
              return q.resolve(null);
            } else {
              if (debug) {
                console.log('find result is ');
              }
              if (debug) {
                console.dir(item);
              }
              if (!item || item[property] !== value) {
                return q.resolve(null);
              } else {
                return q.resolve(item);
              }
            }
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.findMany = function(_type, property, _value) {
      var q, type, value;
      value = _value || "";
      if (value) {
        value = value.toString();
        value = value.replace(/[^\w\s@.-]/gi, '');
      }
      if (debug) {
        console.log('Mongo findmany called for type ' + _type + ' property ' + property + ' and value ' + value);
      }
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          var query;
          query = {};
          query[property] = value;
          if (debug) {
            console.log('query is ');
          }
          if (debug) {
            console.dir(query);
          }
          return collection.find(query, function(err, cursor) {
            if (err) {
              console.log('MONGO findQuery Error: ' + err);
              console.dir(err);
              return q.resolve(null);
            } else {
              if (cursor && cursor.each) {
                return cursor.each(function(err, el) {
                  if (el === null) {
                    return cursor.toArray((function(_this) {
                      return function(err, items) {
                        if (debug) {
                          console.log('findmany cursor returns');
                        }
                        if (debug) {
                          console.dir(items);
                        }
                        return q.resolve(items);
                      };
                    })(this));
                  }
                });
              } else {
                return q.resolve(null);
              }
            }
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.findQuery = function(_type, query) {
      var q, type;
      if (debug) {
        console.log('Mongo findQuery called for type ' + _type);
      }
      if (debug) {
        console.dir(query);
      }
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          var options, qu, value;
          value = query.value || "";
          if (value) {
            value = value.toString();
            value = value.replace(/[^\w\s@.-]/gi, '');
          }
          qu = {};
          qu[query.property] = value;
          if (query.wildcard) {
            qu[query.property || 'name'] = new RegExp('^' + value + '.');
          }
          options = {};
          if (query.limit) {
            options.limit = query.limit;
          } else {
            options.limit = 10;
          }
          if (query.skip) {
            options.skip = query.skip;
          }
          if (query.sort) {
            options.sort = query.sort;
          }
          if (debug) {
            console.log('query is ');
          }
          if (debug) {
            console.dir(qu);
          }
          if (debug) {
            console.log('options are ');
          }
          if (debug) {
            console.dir(options);
          }
          return collection.find(qu, options, function(err, cursor) {
            var arr;
            if (err) {
              console.log('MONGO findQuery Error: ' + err);
              console.dir(err);
              return q.resolve(null);
            } else {
              arr = [];
              return cursor.each(function(err, el) {
                if (el === null) {
                  return cursor.toArray((function(_this) {
                    return function(err, items) {
                      if (debug) {
                        console.log('findQuery cursor returns');
                      }
                      if (debug) {
                        console.dir(items);
                      }
                      return q.resolve(items);
                    };
                  })(this));
                }
              });
            }
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.search = function(_type, property, _value) {
      var q, type, value;
      value = _value || "";
      if (value) {
        value = value.toString();
        value = value.replace(/[^\w\s@.]/gi, '');
      }
      console.log('Mongo search called for type ' + _type + ' property ' + property + ' and value ' + value);
      q = defer();
      type = _type.toLowerCase();
      this.getDbFor(type).then((function(_this) {
        return function(collection) {
          var query;
          query = {};
          query[property] = {
            $regex: '^' + value
          };
          if (debug) {
            console.log('mongo find query is');
          }
          if (debug) {
            console.dir(query);
          }
          return collection.find(query, function(err, items) {
            if (err) {
              console.log('MONGO search Error: ' + err);
              console.dir(err);
              return q.resolve(null);
            } else {
              return items.toArray(function(err2, docs) {
                if (err2) {
                  console.log('MONGO search toArray Error: ' + err2);
                  return console.dir(err2);
                } else {
                  return q.resolve(docs);
                }
              });
            }
          });
        };
      })(this));
      return q;
    };

    MongoPersistence.prototype.set = function(_type, obj, cb) {
      var type;
      type = _type.toLowerCase();
      return this.getDbFor(type).then((function(_this) {
        return function(collection) {
          if (typeof obj.id === 'object') {
            console.dir(obj);
          }
          return collection.update({
            id: obj.id
          }, obj, {
            upsert: true
          }, function(err, result, details) {
            if (err) {
              console.log('MONGO set Error: ' + err);
              console.dir(err);
              return cb(null);
            } else {
              return cb(result);
            }
          });
        };
      })(this));
    };

    MongoPersistence.prototype.remove = function(_type, obj, cb) {
      var type;
      type = _type.toLowerCase();
      return this.getDbFor(type).then((function(_this) {
        return function(collection) {
          return collection.remove({
            id: obj.id
          }, {
            w: 1
          }, function(err, numberOfRemovedDocs) {
            if (err) {
              console.log('MONGO remove Error: ' + err);
              console.dir(err);
              return cb(null);
            } else {
              return cb(obj);
            }
          });
        };
      })(this));
    };

    return MongoPersistence;

  })();

  module.exports = MongoPersistence;

}).call(this);

//# sourceMappingURL=MongoPersistence.js.map
