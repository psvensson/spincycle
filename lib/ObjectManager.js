// Generated by CoffeeScript 1.8.0
(function() {
  var ClientEndpoints, DB, ObjectManager, SuperModel, debug, defer, e, error, objStore, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  util = require('util');

  defer = require('node-promise').defer;

  SuperModel = require('./SuperModel');

  e = require('./EventManager');

  DB = require('./DB');

  ClientEndpoints = require('./ClientEndpoints');

  objStore = require('./OStore');

  error = require('./Error').error;

  debug = process.env["DEBUG"];

  ObjectManager = (function() {
    function ObjectManager(messageRouter) {
      this.messageRouter = messageRouter;
      this.onDeregisterForUpdatesOn = __bind(this.onDeregisterForUpdatesOn, this);
      this.onRegisterForUpdatesOn = __bind(this.onRegisterForUpdatesOn, this);
      this.resolveReferences = __bind(this.resolveReferences, this);
      this.onUpdateObject = __bind(this.onUpdateObject, this);
      this.getObjectPullThrough = __bind(this.getObjectPullThrough, this);
      this.expose = __bind(this.expose, this);
      this._listObjects = __bind(this._listObjects, this);
      this._getObject = __bind(this._getObject, this);
      this._updateObject = __bind(this._updateObject, this);
      this._deleteObject = __bind(this._deleteObject, this);
      this._createObject = __bind(this._createObject, this);
      this.onGetModelFor = __bind(this.onGetModelFor, this);
      this.onListTypes = __bind(this.onListTypes, this);
      this.registerUpdateObjectHook = __bind(this.registerUpdateObjectHook, this);
      this.setup = __bind(this.setup, this);
      this.updateObjectHooks = [];
    }

    ObjectManager.prototype.setup = function() {
      this.messageRouter.addTarget('registerForUpdatesOn', 'obj', this.onRegisterForUpdatesOn);
      this.messageRouter.addTarget('deRegisterForUpdatesOn', 'id,listenerid', this.onDeregisterForUpdatesOn);
      this.messageRouter.addTarget('updateObject', 'obj', this.onUpdateObject);
      this.messageRouter.addTarget('listTypes', '<noargs>', this.onListTypes);
      return this.messageRouter.addTarget('getModelFor', 'modelname', this.onGetModelFor);
    };

    ObjectManager.prototype.registerUpdateObjectHook = function(hook) {
      return this.updateObjectHooks.push(hook);
    };

    ObjectManager.prototype.onListTypes = function(msg) {
      return msg.replyFunc({
        status: e.general.SUCCESS,
        info: 'list types',
        payload: objStore.listTypes()
      });
    };

    ObjectManager.prototype.onGetModelFor = function(msg) {
      if (msg.modelname) {
        return this.messageRouter.resolver.resolve(msg.modelname, (function(_this) {
          return function(path) {
            var model, rv;
            if (debug) {
              console.log('onGetModelFor ' + msg.modelname + ' got back require path ' + path);
            }
            model = require(path);
            if (debug) {
              console.log('got model resolved to');
            }
            if (debug) {
              console.dir(model);
            }
            rv = [];
            model.model.forEach(function(property) {
              if (property["public"]) {
                return rv.push(property);
              }
            });
            return msg.replyFunc({
              status: e.general.SUCCESS,
              info: 'get model',
              payload: rv
            });
          };
        })(this));
      } else {
        return msg.replyFunc({
          status: e.general.FAILURE,
          info: "missing parameter",
          payload: null
        });
      }
    };

    ObjectManager.prototype._createObject = function(msg) {
      if (msg.obj.type) {
        if (this.messageRouter.authMgr.canUserCreateThisObject(msg.obj.type, msg.user)) {
          console.dir(msg);
          msg.obj.createdAt = Date.now();
          msg.obj.createdBy = msg.user.id;
          return SuperModel.resolver.createObjectFrom(msg.obj).then((function(_this) {
            return function(o) {
              o.serialize();
              return msg.replyFunc({
                status: e.general.SUCCESS,
                info: 'new ' + msg.obj.type,
                payload: o
              });
            };
          })(this));
        } else {
          return msg.replyFunc({
            status: e.general.NOT_ALLOWED,
            info: 'not allowed to create objects of that type',
            payload: msg.obj.type
          });
        }
      } else {
        return msg.replyFunc({
          status: e.general.FAILURE,
          info: 'missing parameter',
          payload: null
        });
      }
    };

    ObjectManager.prototype._deleteObject = function(msg) {
      if (msg.obj && msg.obj.type && msg.obj.id) {
        return objStore.getObject(msg.obj.id, msg.obj.type).then((function(_this) {
          return function(obj) {
            if (obj) {
              if (_this.messageRouter.authMgr.canUserWriteToThisObject(obj, msg.user)) {
                return DB.remove(obj, function(removestatus) {
                  if (debug) {
                    console.log('exposed object removed through _delete' + msg.obj.type);
                  }
                  objStore.removeObject(obj);
                  return msg.replyFunc({
                    status: e.general.SUCCESS,
                    info: 'delete object',
                    payload: obj.id
                  });
                });
              } else {
                return msg.replyFunc({
                  status: e.general.NOT_ALLOWED,
                  info: 'not allowed to delete object',
                  payload: msg.obj.id
                });
              }
            } else {
              console.log('No object found with id ' + msg.obj.id);
              console.dir(objStore.objects.map(function(o) {
                return o.type === msg.obj.type;
              }));
              return msg.replyFunc({
                status: e.general.NOT_ALLOWED,
                info: e.gamemanager.NO_SUCH_OBJECT,
                payload: msg.obj.id
              });
            }
          };
        })(this));
      } else {
        return msg.replyFunc({
          status: e.general.FAILURE,
          info: 'missing parameter',
          payload: null
        });
      }
    };

    ObjectManager.prototype._updateObject = function(msg) {
      return this.onUpdateObject(msg);
    };

    ObjectManager.prototype._getObject = function(msg) {
      if (debug) {
        console.log('_getObject called for type ' + msg.type);
      }
      if (msg.type && msg.obj.id) {
        if (typeof msg.obj.id === 'string') {
          return this.getObjectPullThrough(msg.obj.id, msg.obj.type).then((function(_this) {
            return function(obj) {
              if (obj) {
                if (_this.messageRouter.authMgr.canUserReadFromThisObject(obj, msg.user)) {
                  return msg.replyFunc({
                    status: e.general.SUCCESS,
                    info: 'get object',
                    payload: obj.toClient()
                  });
                } else {
                  return msg.replyFunc({
                    status: e.general.NOT_ALLOWED,
                    info: 'not allowed to read from that object',
                    payload: msg.obj.id
                  });
                }
              } else {
                console.log('No object found with id ' + msg.obj.id);
                console.dir(objStore.objects.map(function(o) {
                  return o.type === msg.obj.type;
                }));
                return msg.replyFunc({
                  status: e.general.NOT_ALLOWED,
                  info: e.gamemanager.NO_SUCH_OBJECT,
                  payload: msg.obj.id
                });
              }
            };
          })(this));
        } else {
          return msg.replyFunc({
            status: e.general.FAILURE,
            info: 'id parameter in wrong format',
            payload: null
          });
        }
      } else {
        return msg.replyFunc({
          status: e.general.FAILURE,
          info: 'missing parameter',
          payload: null
        });
      }
    };

    ObjectManager.prototype._listObjects = function(msg) {
      var rv;
      console.log('listObjects called for type ' + msg.type);
      if (typeof msg.type !== 'undefined') {
        if (!this.messageRouter.authMgr.canUserListTheseObjects(msg.type, msg.user)) {
          return msg.replyFunc({
            status: e.general.NOT_ALLOWED,
            info: 'not allowed to list objects of type ' + msg.type,
            payload: msg.type
          });
        } else {
          rv = objStore.listObjectsByType(msg.type);
          console.log('found ' + rv.length + ' objects to return');
          return msg.replyFunc({
            status: e.general.SUCCESS,
            info: 'list objects',
            payload: rv
          });
        }
      } else {
        return msg.replyFunc({
          status: e.general.FAILURE,
          info: 'missing parameter',
          payload: null
        });
      }
    };

    ObjectManager.prototype.expose = function(type) {
      objStore.types[type] = type;
      return this.messageRouter.expose(type);
    };

    ObjectManager.prototype.getObjectPullThrough = function(id, type) {
      var q;
      q = defer();
      if (!type) {
        console.log('Objectmanager::getObjectPullThrough called with null type.');
        q.resolve(null);
      } else {
        objStore.getObject(id, type).then((function(_this) {
          return function(o) {
            if (!o) {
              console.log('did not find object i ostore, getting from db');
              return DB.get(type, [id]).then(function(record) {
                return _this.messageRouter.resolver.createObjectFrom(record).then(function(oo) {
                  return q.resolve(oo);
                });
              });
            } else {
              return q.resolve(o);
            }
          };
        })(this));
      }
      return q;
    };

    ObjectManager.prototype.onUpdateObject = function(msg) {
      console.log('onUpdateObject called for ' + msg.obj.type + ' - ' + msg.obj.id);
      return objStore.getObject(msg.obj.id, msg.obj.type).then((function(_this) {
        return function(obj) {
          if (obj) {
            if (_this.messageRouter.authMgr.canUserWriteToThisObject(obj, msg.user)) {
              if (debug) {
                console.log('can write');
              }
              return _this.resolveReferences(msg.obj, obj.constructor.model).then(function(robj) {
                var record;
                if (debug) {
                  console.log('found object');
                }
                objStore.updateObj(robj);
                if (debug) {
                  console.log('persisting ' + obj.id + ' type ' + obj.type + ' in db');
                }
                record = obj.getRecord();
                obj.serialize();
                _this.updateObjectHooks.forEach(function(hook) {
                  return hook(record);
                });
                return msg.replyFunc({
                  status: e.general.SUCCESS,
                  info: e.gamemanager.UPDATE_OBJECT_SUCCESS,
                  payload: msg.obj.id
                });
              });
            } else {
              return msg.replyFunc({
                status: e.general.NOT_ALLOWED,
                info: e.gamemanager.UPDATE_OBJECT_FAIL,
                payload: msg.obj.id
              });
            }
          } else {
            console.log('No object found with id ' + msg.obj.id);
            console.dir(objStore.objects.map(function(o) {
              return o.type === msg.obj.type;
            }));
            return msg.replyFunc({
              status: e.general.NOT_ALLOWED,
              info: e.gamemanager.NO_SUCH_OBJECT,
              payload: msg.obj.id
            });
          }
        };
      })(this));
    };

    ObjectManager.prototype.resolveReferences = function(record, model) {
      var checkFinished, count, q, rv;
      if (debug) {
        console.log('resolveReferences model is ');
      }
      if (debug) {
        console.dir(model);
      }
      rv = {
        id: record.id
      };
      q = defer();
      count = model.length;
      checkFinished = function() {
        if (debug) {
          console.log('checkFinished count = ' + count);
        }
        if (--count === 0) {
          return q.resolve(rv);
        }
      };
      model.forEach((function(_this) {
        return function(property) {
          var acount, arr, harr, hcount, resolvedarr, resolvedhash;
          if (property.array) {
            resolvedarr = [];
            arr = record[property.name] || [];
            acount = arr.length;
            if (acount === 0) {
              rv[property.name] = [];
              return checkFinished();
            } else {
              return arr.forEach(function(id) {
                if (debug) {
                  console.log('attempting to get object type ' + property.type + ' id ' + id);
                }
                return _this.getObjectPullThrough(id, property.type).then(function(o) {
                  resolvedarr.push(o);
                  if (debug) {
                    console.log('adding array reference ' + o.id + ' name ' + o.name);
                  }
                  if (--acount === 0) {
                    rv[property.name] = resolvedarr;
                    return checkFinished();
                  }
                });
              });
            }
          } else if (property.hashtable) {
            resolvedhash = {};
            harr = record[property.name] || [];
            hcount = harr.length;
            if (hcount === 0) {
              rv[property.name] = [];
              return checkFinished();
            } else {
              return harr.forEach(function(id) {
                return _this.getObjectPullThrough(id, property.type).then(function(o) {
                  resolvedhash[o.name] = o;
                  if (debug) {
                    console.log('adding hashtable reference ' + o.id + ' name ' + o.name);
                  }
                  if (--hcount === 0) {
                    rv[property.name] = resolvedhash;
                    return checkFinished();
                  }
                });
              });
            }
          } else {
            if (debug) {
              console.log('resolveReference adding direct reference ' + property.name);
            }
            rv[property.name] = record[property.name];
            return checkFinished();
          }
        };
      })(this));
      return q;
    };

    ObjectManager.prototype.onRegisterForUpdatesOn = function(msg) {
      if (debug) {
        console.dir(msg);
      }
      if (msg.obj || !msg.obj.id || !msg.obj.type) {
        if (debug) {
          console.log('onRegisterForUpdatesOn called for ' + msg.obj.type + ' ' + msg.obj.id);
        }
        if (typeof msg.obj.id === 'string') {
          objStore.getObject(msg.obj.id, msg.obj.type).then((function(_this) {
            return function(obj) {
              var listenerId;
              if (obj && obj.id) {
                if (_this.messageRouter.authMgr.canUserReadFromThisObject(obj, msg.user)) {
                  listenerId = objStore.addListenerFor(msg.obj.id, msg.obj.type, function(uobj) {
                    if (debug) {
                      console.log('--------------------- sending update of object ' + msg.obj.id + ' type ' + msg.obj.type + ' to client');
                    }
                    return ClientEndpoints.sendToEndpoint(msg.client, {
                      status: e.general.SUCCESS,
                      info: e.gamemanager.OBJECT_UPDATE,
                      payload: uobj.toClient()
                    });
                  });
                  if (debug) {
                    console.log('listenerid ' + listenerId + ' added for updates on object ' + obj.name + ' [' + obj.id + ']');
                  }
                  return msg.replyFunc({
                    status: e.general.SUCCESS,
                    info: e.gamemanager.REGISTER_UPDATES,
                    payload: listenerId
                  });
                } else {
                  return msg.replyFunc({
                    status: e.general.NOT_ALLOWED,
                    info: e.gamemanager.UPDATE_REGISTER_FAIL,
                    payload: msg.obj.id
                  });
                }
              } else {
                console.dir(obj);
                return msg.replyFunc({
                  status: e.general.NOT_ALLOWED,
                  info: e.gamemanager.NO_SUCH_OBJECT,
                  payload: msg.obj.id
                });
              }
            };
          })(this), error);
        } else {

        }
        return msg.replyFunc({
          status: e.general.FAILURE,
          info: 'wrong parameter format',
          payload: 'id'
        });
      } else {
        return msg.replyFunc({
          status: e.general.FAILURE,
          info: 'missing parameter',
          payload: null
        });
      }
    };

    ObjectManager.prototype.onDeregisterForUpdatesOn = function(msg) {
      if (debug) {
        console.log('onDeregisterForUpdatesOn called for id ' + msg.id + ' and listener id ' + msg.listenerid);
      }
      if (msg.id && msg.listenerid && msg.type) {
        objStore.removeListenerFor(msg.id, msg.listenerid);
        return msg.replyFunc({
          status: e.general.SUCCESS,
          info: 'deregistered listener for obejct',
          payload: msg.id
        });
      } else {
        return msg.replyFunc({
          status: e.general.FAILURE,
          info: 'missing parameter',
          payload: null
        });
      }
    };

    return ObjectManager;

  })();

  module.exports = ObjectManager;

}).call(this);

//# sourceMappingURL=ObjectManager.js.map
