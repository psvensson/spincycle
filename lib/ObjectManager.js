// Generated by CoffeeScript 1.9.1
(function() {
  var ClientEndpoints, DB, ObjectManager, SuperModel, defer, e, error, objStore, util,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  util = require('util');

  defer = require('node-promise').defer;

  SuperModel = require('./SuperModel');

  e = require('./EventManager');

  DB = require('./DB');

  ClientEndpoints = require('./ClientEndpoints');

  objStore = require('./OStore');

  error = require('./Error').error;

  ObjectManager = (function() {
    function ObjectManager(messageRouter) {
      this.messageRouter = messageRouter;
      this.onDeregisterForUpdatesOn = bind(this.onDeregisterForUpdatesOn, this);
      this.onRegisterForUpdatesOn = bind(this.onRegisterForUpdatesOn, this);
      this.onUpdateObject = bind(this.onUpdateObject, this);
      this.expose = bind(this.expose, this);
      this.onGetModelFor = bind(this.onGetModelFor, this);
      this.onListTypes = bind(this.onListTypes, this);
      this.registerUpdateObjectHook = bind(this.registerUpdateObjectHook, this);
      this.setup = bind(this.setup, this);
      this.updateObjectHooks = [];
    }

    ObjectManager.prototype.setup = function() {
      this.messageRouter.addTarget('registerForUpdatesOn', 'obj', this.onRegisterForUpdatesOn);
      this.messageRouter.addTarget('deRegisterForUpdatesOn', 'id,listenerid', this.onRegisterForUpdatesOn);
      this.messageRouter.addTarget('updateObject', 'obj', this.onUpdateObject);
      this.messageRouter.addTarget('listTypes', '<noargs>', this.onListTypes);
      return this.messageRouter.addTarget('getModelFor', 'modelname', this.onGetModelFor);
    };

    ObjectManager.prototype.registerUpdateObjectHook = function(hook) {
      return this.updateObjectHooks.push(hook);
    };

    ObjectManager.prototype.onListTypes = function(msg) {
      return msg.replyFunc({
        status: e.general.SUCCESS,
        info: 'list types',
        payload: objStore.listTypes()
      });
    };

    ObjectManager.prototype.onGetModelFor = function(msg) {
      return msg.replyFunc({
        status: e.general.SUCCESS,
        info: 'get model',
        payload: model
      });
    };

    ObjectManager.prototype.expose = function(type) {
      objStore.types[type] = type;
      this.messageRouter.addTarget('_create' + type, 'obj', (function(_this) {
        return function(msg) {
          console.dir(msg);
          if (msg.odata.type === type && _this.messageRouter.authMgr.canUserCreateThisObject(msg.odata, msg.user)) {
            return SuperModel.resolver.createObjectFrom(msg.odata).then(function(o) {
              return msg.replyFunc({
                status: e.general.SUCCESS,
                info: 'new ' + type,
                payload: o.id
              });
            });
          }
        };
      })(this));
      this.messageRouter.addTarget('_delete' + type, 'obj', (function(_this) {
        return function(msg) {
          return objStore.getObject(msg.obj.id, msg.obj.type.then(function(obj) {
            if (obj) {
              if (_this.messageRouter.authMgr.canUserWriteToThisObject(obj, msg.user)) {
                return DB.remove(obj, function(removestatus) {
                  console.log('exposed object removed through _delete' + type);
                  objStore.removeObject(obj);
                  return msg.replyFunc({
                    status: e.general.SUCCESS,
                    info: 'delete object',
                    payload: obj.id
                  });
                });
              } else {
                return msg.replyFunc({
                  status: e.general.NOT_ALLOWED,
                  info: 'not allowed to delete object',
                  payload: msg.obj.id
                });
              }
            } else {
              console.log('No object found with id ' + msg.obj.id);
              console.dir(objStore.objects.map(function(o) {
                return o.type === msg.obj.type;
              }));
              return msg.replyFunc({
                status: e.general.NOT_ALLOWED,
                info: e.gamemanager.NO_SUCH_OBJECT,
                payload: msg.obj.id
              });
            }
          }));
        };
      })(this));
      this.messageRouter.addTarget('_update' + type, 'obj', (function(_this) {
        return function(msg) {
          return _this.onUpdateObject(msg);
        };
      })(this));
      this.messageRouter.addTarget('_get' + type, 'obj', (function(_this) {
        return function(msg) {
          return objStore.getObject(msg.obj.id, msg.obj.type.then(function(obj) {
            if (obj) {
              return msg.replyFunc({
                status: e.general.SUCCESS,
                info: 'get object',
                payload: obj.toClient()
              });
            } else {
              console.log('No object found with id ' + msg.obj.id);
              console.dir(objStore.objects.map(function(o) {
                return o.type === msg.obj.type;
              }));
              return msg.replyFunc({
                status: e.general.NOT_ALLOWED,
                info: e.gamemanager.NO_SUCH_OBJECT,
                payload: msg.obj.id
              });
            }
          }));
        };
      })(this));
      return this.messageRouter.addTarget('_list' + type + 's', '<noargs>', (function(_this) {
        return function(msg) {
          var rv;
          if (!_this.messageRouter.authMgr.canUserListTheseObjects(msg.type, msg.user)) {
            return msg.replyFunc({
              status: e.general.NOT_ALLOWED,
              info: 'not allowed to list objects of type ' + msg.type,
              payload: msg.type
            });
          } else {
            rv = objStore.listObjectsByType(msg.type);
            return msg.replyFunc({
              status: e.general.SUCCESS,
              info: 'list objects',
              payload: rv
            });
          }
        };
      })(this));
    };

    ObjectManager.prototype.onUpdateObject = function(msg) {
      console.log('onUpdateObject called for ' + msg.obj.type + ' - ' + msg.obj.id);
      return objStore.getObject(msg.obj.id, msg.obj.type).then((function(_this) {
        return function(obj) {
          var record;
          if (obj) {
            if (_this.messageRouter.authMgr.canUserWriteToThisObject(obj, msg.user)) {
              objStore.updateObj(msg.obj);
              console.log('persisiting ' + obj.id + ' rev ' + obj._rev + ' in db');
              record = obj._getRecord();
              DB.set(obj.type, record);
              _this.updateObjectHooks.forEach(function(hook) {
                return hook(record);
              });
              return msg.replyFunc({
                status: e.general.SUCCESS,
                info: e.gamemanager.UPDATE_OBJECT_SUCCESS,
                payload: msg.obj.id
              });
            } else {
              return msg.replyFunc({
                status: e.general.NOT_ALLOWED,
                info: e.gamemanager.UPDATE_OBJECT_FAIL,
                payload: msg.obj.id
              });
            }
          } else {
            console.log('No object found with id ' + msg.obj.id);
            console.dir(objStore.objects.map(function(o) {
              return o.type === msg.obj.type;
            }));
            return msg.replyFunc({
              status: e.general.NOT_ALLOWED,
              info: e.gamemanager.NO_SUCH_OBJECT,
              payload: msg.obj.id
            });
          }
        };
      })(this));
    };

    ObjectManager.prototype.onRegisterForUpdatesOn = function(msg) {
      console.log('onRegisterForUpdatesOn called for ' + msg.obj.type + ' ' + msg.obj.id);
      return objStore.getObject(msg.obj.id, msg.obj.type).then((function(_this) {
        return function(obj) {
          var listenerId;
          if (obj && obj.id) {
            if (_this.messageRouter.authMgr.canUserReadFromThisObject(obj, msg.user)) {
              listenerId = objStore.addListenerFor(msg.obj.id, msg.obj.type, function(uobj) {
                console.log('--------------------- sending update of object ' + msg.obj.id + ' type ' + msg.obj.type + ' to client');
                return ClientEndpoints.sendToEndpoint(msg.client, {
                  status: e.general.SUCCESS,
                  info: e.gamemanager.OBJECT_UPDATE,
                  payload: uobj.toClient()
                });
              });
              return msg.replyFunc({
                status: e.general.SUCCESS,
                info: e.gamemanager.REGISTER_UPDATES,
                payload: listenerId
              });
            } else {
              return msg.replyFunc({
                status: e.general.NOT_ALLOWED,
                info: e.gamemanager.UPDATE_REGISTER_FAIL,
                payload: msg.obj.id
              });
            }
          } else {
            console.dir(obj);
            return msg.replyFunc({
              status: e.general.NOT_ALLOWED,
              info: e.gamemanager.NO_SUCH_OBJECT,
              payload: msg.obj.id
            });
          }
        };
      })(this), error);
    };

    ObjectManager.prototype.onDeregisterForUpdatesOn = function(msg) {
      console.log('onDeregisterForUpdatesOn called for id ' + msg.id + ' and listener id ' + msg.listenerid);
      objStore.removeListenerFor(msg.id, msg.obj.listenerid);
      return msg.replyFunc({
        status: e.general.SUCCESS,
        info: 'deregistered listener for obejct',
        payload: msg.id
      });
    };

    return ObjectManager;

  })();

  module.exports = ObjectManager;

}).call(this);

//# sourceMappingURL=ObjectManager.js.map
