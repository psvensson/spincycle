// Generated by CoffeeScript 1.10.0
(function() {
  var ClientEndpoints, DB, EventManager, HttpMethod, MessageRouter, OStore, ObjectManager, RateLimiter, RedisMethod, ResolveModule, SpinFunction, SpinModule, SuperModel, WsMethod, e, error, express, path,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ObjectManager = require('./ObjectManager');

  error = require('./Error').error;

  HttpMethod = require('./HttpMethod');

  WsMethod = require('./WsMethod');

  RedisMethod = require('./RedisMethod');

  DB = require('./DB');

  EventManager = require('./EventManager');

  SuperModel = require('./SuperModel');

  SpinModule = require('./SpinModule');

  SpinFunction = require('./SpinFunction');

  ClientEndpoints = require('./ClientEndpoints');

  OStore = require('./OStore');

  ResolveModule = require('./ResolveModule');

  RateLimiter = require('limiter').RateLimiter;

  e = require('./EventManager');

  express = require("express");

  path = require('path');

  MessageRouter = (function() {
    var debug;

    MessageRouter.HttpMethod = HttpMethod;

    MessageRouter.WsMethod = WsMethod;

    MessageRouter.RedisMethod = RedisMethod;

    MessageRouter.DB = DB;

    MessageRouter.EventManager = EventManager;

    MessageRouter.SuperModel = SuperModel;

    MessageRouter.ObjectManager = ObjectManager;

    MessageRouter.ClientEndpoints = ClientEndpoints;

    MessageRouter.OStore = OStore;

    MessageRouter.ResolveModule = ResolveModule;

    MessageRouter.status = 'closed';

    debug = process.env["DEBUG"];

    function MessageRouter(authMgr, dburl, msgPS, app, dbtype) {
      var pjson;
      this.authMgr = authMgr;
      this.app = app;
      if (dbtype == null) {
        dbtype = 'mongodb';
      }
      this.routeMessage = bind(this.routeMessage, this);
      this.removeTarget = bind(this.removeTarget, this);
      this.addTarget = bind(this.addTarget, this);
      this.addMethod = bind(this.addMethod, this);
      this.close = bind(this.close, this);
      this.open = bind(this.open, this);
      this.expose = bind(this.expose, this);
      this.addServicePage = bind(this.addServicePage, this);
      this.setup = bind(this.setup, this);
      MessageRouter.DB.dburl = dburl;
      MessageRouter.DB.dbname = dbtype;
      DB.getDataStore(dbtype);
      pjson = require('../package.json');
      this.messagesPerSecond = msgPS || 100;
      console.log('SpinCycle messageRouter constructor. Version - ' + pjson.version + ' messages per second limit = ' + this.messagesPerSecond);
      this.authMgr.messagerouter = this;
      this.resolver = new ResolveModule();
      ResolveModule.modulecache['SpinModule'] = SpinModule;
      ResolveModule.modulecache['SpinFunction'] = SpinFunction;
      this.targets = [];
      this.debugtargets = [];
      this.args = [];
      this.methods = [];
      this.objectManager = new ObjectManager(this);
      this.objectManager.setup();
      if (this.authMgr.setup) {
        this.authMgr.setup(this);
      }
      this.setup();
    }

    MessageRouter.prototype.setup = function() {
      this.addTarget('listcommands', '<noargs>', (function(_this) {
        return function(msg) {
          var name, ref, rv, target;
          rv = {
            listcommands: '<noarg>'
          };
          ref = _this.targets;
          for (name in ref) {
            target = ref[name];
            rv[name] = _this.args[name];
          }
          return msg.replyFunc({
            status: EventManager.general.SUCCESS,
            info: 'list of available targets',
            payload: rv
          });
        };
      })(this));
      return this.addServicePage();
    };

    MessageRouter.prototype.addServicePage = function() {
      var p;
      p = path.join(__dirname, 'spin');
      console.log('**************** addServicePage called -> ' + p);
      if (this.app) {
        this.app.use('/spin/', express["static"](path.join(__dirname, 'spin')));
      }
      console.log('**************** exposing SpinModule and SpinFunction');
      this.objectManager.expose('SpinModule');
      return this.objectManager.expose('SpinFunction');
    };

    MessageRouter.prototype.expose = function(type) {
      var method, name, ref, results;
      ref = this.methods;
      results = [];
      for (name in ref) {
        method = ref[name];
        results.push(method.expose(type));
      }
      return results;
    };

    MessageRouter.prototype.open = function() {
      MessageRouter.status = 'open';
      return console.log('opening message router');
    };

    MessageRouter.prototype.close = function() {
      MessageRouter.status = 'closed';
      return console.log('closing message router');
    };

    MessageRouter.prototype.addMethod = function(methodName, method) {
      var results, targetName;
      console.log('addMethod called for "' + methodName + '"');
      this.methods[methodName] = method;
      results = [];
      for (targetName in this.targets) {
        results.push(method.registrationFunc(targetName, this.routeMessage));
      }
      return results;
    };

    MessageRouter.prototype.addTarget = function(targetName, args, targetFunc, props) {
      var method, name, ref, results;
      this.targets[targetName] = targetFunc;
      this.args[targetName] = args;
      ref = this.methods;
      results = [];
      for (name in ref) {
        method = ref[name];
        if (method.registrationFunc) {
          results.push(method.registrationFunc(targetName, this.routeMessage, props));
        } else {
          console.log('Spincycle did NOT find target for ' + targetName);
          console.log('----------------methods-------------------');
          results.push(console.dir(this.methods));
        }
      }
      return results;
    };

    MessageRouter.prototype.removeTarget = function(targetName) {
      return this.targets[targetName] = null;
    };

    MessageRouter.prototype.routeMessage = function(message) {
      var fn;
      if (MessageRouter.status !== 'open') {
        return message.replyFunc({
          status: e.general.NOT_ALLOWED,
          info: 'Message router is not yet open',
          payload: {
            error: 'ERRCHILLMAN'
          }
        });
      } else {
        fn = this.targets[message.target];
        if (fn) {
          return this.authMgr.decorateMessageWithUser(message).then((function(_this) {
            return function(m) {
              if (!m.user) {
                console.log('** SpinCycle did not get message decorated with user property from AuthenticationManager **');
                exit(-1);
              }
              if (!m.user.limiter) {
                console.log('--- creating new rate limiter for user ' + m.user.id + ' max request = ' + parseInt(_this.messagesPerSecond));
                m.user.limiter = new RateLimiter(parseInt(_this.messagesPerSecond), 1000);
              }
              if (m.user.limiter && m.user.limiter.removeTokens) {
                return m.user.limiter.removeTokens(1, function(err, remainingRequests) {
                  if (parseInt(remainingRequests) < 1) {
                    return m.replyFunc({
                      status: e.general.NOT_ALLOWED,
                      info: 'packets over ' + _this.messagesPerSecond + '/s dropped. Have a nice day.',
                      payload: {
                        error: 'TOOMANYPACKETSPERSECOND'
                      }
                    });
                  } else {
                    return fn(m);
                  }
                });
              } else {
                console.log('** user ' + m.user.name + ' have no ratelimiter or at least not one with a removeToken function!!!');
                return console.dir(m.user);
              }
            };
          })(this));
        } else {
          return console.log('--- could not find registered target for message! ---');
        }
      }
    };

    return MessageRouter;

  })();

  module.exports = MessageRouter;

}).call(this);

//# sourceMappingURL=MessageRouter.js.map
