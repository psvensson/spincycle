// Generated by CoffeeScript 1.8.0
(function() {
  window.spinc = {
    subscribers: [],
    objsubscribers: [],
    objectsSubscribedTo: [],
    outstandingMessages: [],
    modelcache: [],
    rightscache: [],
    io: null,
    sessionId: null,
    objects: [],
    failureMessage: void 0,
    failed: function(msg) {
      return console.log('spinclient message failed!! ' + msg);
    },
    setSessionId: function(id) {
      if (id) {
        console.log('++++++++++++++++++++++++++++++++++++++ spinclient setting session id to ' + id);
        return service.sessionId = id;
      }
    },
    dumpOutstanding: function() {},
    setWebSocketInstance: (function(_this) {
      return function(io) {
        service.io = io;
        return service.io.on('message', function(reply) {
          var detail, i, index, info, message, status, subscribers;
          status = reply.status;
          message = reply.payload;
          info = reply.info;
          service.dumpOutstanding();
          index = -1;
          if (reply.messageId) {
            i = 0;
            while (i < service.outstandingMessages.length) {
              detail = service.outstandingMessages[i];
              if (detail.messageId === reply.messageId) {
                if (reply.status === 'FAILURE') {
                  console.log('spinclient message FAILURE');
                  console.dir(reply);
                  service.failuremessage = reply.info;
                  service.infomessage = '';
                  detail.d.reject(reply);
                  break;
                } else {
                  service.infomessage = reply.info;
                  service.failuremessage = '';
                  detail.d.resolve(message);
                  index = i;
                  break;
                }
              }
              i++;
            }
            if (index > -1) {
              return service.outstandingMessages.splice(index, 1);
            }
          } else {
            subscribers = service.subscribers[info];
            if (subscribers) {
              return subscribers.forEach(function(listener) {
                return listener(message);
              });
            } else {
              console.log('no subscribers for message ' + message);
              return console.dir(reply);
            }
          }
        });
      };
    })(this),
    registerListener: function(detail) {
      var subscribers;
      console.log('spinclient::registerListener called for ' + detail.message);
      subscribers = service.subscribers[detail.message] || [];
      subscribers.push(detail.callback);
      return service.subscribers[detail.message] = subscribers;
    },
    registerObjectSubscriber: function(detail) {
      var d, localsubs, sid;
      d = $q.defer();
      sid = uuid4.generate();
      localsubs = service.objectsSubscribedTo[detail.id];
      if (!localsubs) {
        localsubs = [];
        service._registerObjectSubscriber({
          id: detail.id,
          type: detail.type,
          cb: function(updatedobj) {
            var k, lsubs, v, _results;
            lsubs = service.objectsSubscribedTo[detail.id];
            _results = [];
            for (k in lsubs) {
              v = lsubs[k];
              if (v.cb) {
                _results.push(v.cb(updatedobj));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        }).then(function(remotesid) {
          localsubs['remotesid'] = remotesid;
          localsubs[sid] = detail;
          service.objectsSubscribedTo[detail.id] = localsubs;
          return d.resolve(sid);
        });
      }
      return d.promise;
    },
    _registerObjectSubscriber: function(detail) {
      var d, subscribers;
      d = $q.defer();
      subscribers = service.objsubscribers[detail.id] || [];
      service.emitMessage({
        target: 'registerForUpdatesOn',
        obj: {
          id: detail.id,
          type: detail.type
        }
      }).then(function(reply) {
        subscribers[reply] = detail.cb;
        service.objsubscribers[detail.id] = subscribers;
        return d.resolve(reply);
      }, function(reply) {
        return service.failed(reply);
      });
      return d.promise;
    },
    deRegisterObjectSubscriber: (function(_this) {
      return function(sid, o) {
        var count, k, localsubs, v, _i, _len;
        localsubs = service.objectsSubscribedTo[o.id] || [];
        if (localsubs[sid]) {
          console.log('deregistering local updates for object ' + o.id);
          delete localsubs[sid];
          count = 0;
          for (v = _i = 0, _len = localsubs.length; _i < _len; v = ++_i) {
            k = localsubs[v];
            count++;
          }
          if (count === 1) {
            return service._deRegisterObjectSubscriber('remotesid', o);
          }
        }
      };
    })(this),
    _deRegisterObjectSubscriber: (function(_this) {
      return function(sid, o) {
        var subscribers;
        subscribers = service.objsubscribers[o.id] || [];
        if (subscribers && subscribers[sid]) {
          delete subscribers[sid];
          service.objsubscribers[o.id] = subscribers;
          return service.emitMessage({
            target: 'deRegisterForUpdatesOn',
            id: o.id,
            type: o.type,
            listenerid: sid
          }).then(function(reply) {
            return console.log('deregistering server updates for object ' + o.id);
          });
        }
      };
    })(this),
    emitMessage: function(detail) {
      var d, e;
      d = $q.defer();
      try {
        detail.messageId = uuid4.generate();
        detail.sessionId = service.sessionId;
        detail.d = d;
        service.outstandingMessages.push(detail);
        service.io.emit('message', JSON.stringify(detail));
      } catch (_error) {
        e = _error;
        console.log('spinclient emitMessage ERROR: ' + e);
      }
      return d.promise;
    },
    getModelFor: function(type) {
      var d;
      d = $q.defer();
      if (service.modelcache[type]) {
        d.resolve(service.modelcache[type]);
      } else {
        service.emitMessage({
          target: 'getModelFor',
          modelname: type
        }).then(function(model) {
          service.modelcache[type] = model;
          return d.resolve(model);
        });
      }
      return d.promise;
    },
    getRightsFor: function(type) {
      var d;
      d = $q.defer();
      if (service.rightscache[type]) {
        d.resolve(service.rightscache[type]);
      } else {
        service.emitMessage({
          target: 'getAccessTypesFor',
          modelname: type
        }).then(function(rights) {
          service.rightscache[type] = rights;
          return d.resolve(rights);
        });
      }
      return d.promise;
    },
    listTargets: function() {
      var d;
      d = $q.defer();
      service.emitMessage({
        target: 'listcommands'
      }).then(function(targets) {
        return d.resolve(targets);
      });
      return d.promise;
    },
    flattenModel: function(model) {
      var k, rv, v;
      rv = {};
      for (k in model) {
        v = model[k];
        if (angular.isArray(v)) {
          rv[k] = v.map(function(e) {
            return e.id;
          });
        } else {
          rv[k] = v;
        }
      }
      return rv;
    }
  };

  window.spinc.subscribers['OBJECT_UPDATE'] = [
    function(obj) {
      var k, o, prop, subscribers, v, val, _results;
      subscribers = service.objsubscribers[obj.id] || [];
      _results = [];
      for (k in subscribers) {
        v = subscribers[k];
        if (!service.objects[obj.id]) {
          service.objects[obj.id] = obj;
        } else {
          o = service.objects[obj.id];
          for (prop in obj) {
            val = obj[prop];
            o[prop] = val;
          }
        }
        _results.push(v(obj));
      }
      return _results;
    }
  ];

}).call(this);

//# sourceMappingURL=spinc.js.map
