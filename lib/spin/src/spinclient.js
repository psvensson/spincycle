// Generated by CoffeeScript 1.10.0
(function() {
  define('spinclient', ['Q', 'uuid4', 'io'], (function(_this) {
    return function(q, uuid4, io) {
      var spinc;
      spinc = {
        subscribers: [],
        objsubscribers: [],
        objectsSubscribedTo: [],
        outstandingMessages: [],
        modelcache: [],
        rightscache: [],
        io: io(),
        sessionId: null,
        objects: [],
        failureMessage: void 0,
        failed: function(msg) {
          return console.log('spinclient message failed!! ' + msg);
        },
        setSessionId: function(id) {
          if (id) {
            console.log('++++++++++++++++++++++++++++++++++++++ spinclient setting session id to ' + id);
            return spinc.sessionId = id;
          }
        },
        dumpOutstanding: function() {},
        setWebSocketInstance: function(io) {
          spinc.io = io;
          return spinc.io.on('message', function(reply) {
            var detail, i, index, info, message, status, subscribers;
            status = reply.status;
            message = reply.payload;
            info = reply.info;
            spinc.dumpOutstanding();
            index = -1;
            if (reply.messageId) {
              i = 0;
              while (i < spinc.outstandingMessages.length) {
                detail = spinc.outstandingMessages[i];
                if (detail.messageId === reply.messageId) {
                  if (reply.status === 'FAILURE') {
                    console.log('spinclient message FAILURE');
                    console.dir(reply);
                    spinc.failuremessage = reply.info;
                    spinc.infomessage = '';
                    detail.d.reject(reply);
                    break;
                  } else {
                    spinc.infomessage = reply.info;
                    spinc.failuremessage = '';
                    detail.d.resolve(message);
                    index = i;
                    break;
                  }
                }
                i++;
              }
              if (index > -1) {
                return spinc.outstandingMessages.splice(index, 1);
              }
            } else {
              subscribers = spinc.subscribers[info];
              if (subscribers) {
                return subscribers.forEach(function(listener) {
                  console.log("sending reply to listener");
                  console.dir(listener);
                  return listener(message);
                });
              } else {
                console.log('no subscribers for message ' + message);
                return console.dir(reply);
              }
            }
          });
        },
        registerListener: function(detail) {
          var subscribers;
          console.log('spinclient::registerListener called for ' + detail.message);
          subscribers = spinc.subscribers[detail.message] || [];
          subscribers.push(detail.callback);
          return spinc.subscribers[detail.message] = subscribers;
        },
        registerObjectSubscriber: function(detail) {
          var d, localsubs, sid;
          d = q.defer();
          sid = uuid4.generate();
          localsubs = spinc.objectsSubscribedTo[detail.id];
          if (!localsubs) {
            localsubs = [];
            spinc._registerObjectSubscriber({
              id: detail.id,
              type: detail.type,
              cb: function(updatedobj) {
                var k, lsubs, results, v;
                lsubs = spinc.objectsSubscribedTo[detail.id];
                results = [];
                for (k in lsubs) {
                  v = lsubs[k];
                  if (v.cb) {
                    results.push(v.cb(updatedobj));
                  } else {
                    results.push(void 0);
                  }
                }
                return results;
              }
            }).then(function(remotesid) {
              localsubs['remotesid'] = remotesid;
              localsubs[sid] = detail;
              spinc.objectsSubscribedTo[detail.id] = localsubs;
              return d.resolve(sid);
            });
          }
          return d.promise;
        },
        _registerObjectSubscriber: function(detail) {
          var d, subscribers;
          d = q.defer();
          subscribers = spinc.objsubscribers[detail.id] || [];
          spinc.emitMessage({
            target: 'registerForUpdatesOn',
            obj: {
              id: detail.id,
              type: detail.type
            }
          }).then(function(reply) {
            subscribers[reply] = detail.cb;
            spinc.objsubscribers[detail.id] = subscribers;
            return d.resolve(reply);
          }, function(reply) {
            return spinc.failed(reply);
          });
          return d.promise;
        },
        deRegisterObjectSubscriber: function(sid, o) {
          var count, j, k, len, localsubs, v;
          localsubs = spinc.objectsSubscribedTo[o.id] || [];
          if (localsubs[sid]) {
            console.log('deregistering local updates for object ' + o.id);
            delete localsubs[sid];
            count = 0;
            for (v = j = 0, len = localsubs.length; j < len; v = ++j) {
              k = localsubs[v];
              count++;
            }
            if (count === 1) {
              return spinc._deRegisterObjectSubscriber('remotesid', o);
            }
          }
        },
        _deRegisterObjectSubscriber: function(sid, o) {
          var subscribers;
          subscribers = spinc.objsubscribers[o.id] || [];
          if (subscribers && subscribers[sid]) {
            delete subscribers[sid];
            spinc.objsubscribers[o.id] = subscribers;
            return spinc.emitMessage({
              target: 'deRegisterForUpdatesOn',
              id: o.id,
              type: o.type,
              listenerid: sid
            }).then(function(reply) {
              return console.log('deregistering server updates for object ' + o.id);
            });
          }
        },
        emitMessage: function(detail) {
          var d, e, error;
          d = q.defer();
          try {
            detail.messageId = uuid4.generate();
            detail.sessionId = spinc.sessionId;
            detail.d = d;
            spinc.outstandingMessages.push(detail);
            spinc.io.emit('message', JSON.stringify(detail));
          } catch (error) {
            e = error;
            console.log('spinclient emitMessage ERROR: ' + e);
          }
          return d.promise;
        },
        getModelFor: function(type) {
          var d;
          d = q.defer();
          if (spinc.modelcache[type]) {
            d.resolve(spinc.modelcache[type]);
          } else {
            spinc.emitMessage({
              target: 'getModelFor',
              modelname: type
            }).then(function(model) {
              spinc.modelcache[type] = model;
              return d.resolve(model);
            });
          }
          return d.promise;
        },
        getRightsFor: function(type) {
          var d;
          d = q.defer();
          if (spinc.rightscache[type]) {
            d.resolve(spinc.rightscache[type]);
          } else {
            spinc.emitMessage({
              target: 'getAccessTypesFor',
              modelname: type
            }).then(function(rights) {
              spinc.rightscache[type] = rights;
              return d.resolve(rights);
            });
          }
          return d.promise;
        },
        listTargets: function() {
          var d;
          d = q.defer();
          spinc.emitMessage({
            target: 'listcommands'
          }).then(function(targets) {
            return d.resolve(targets);
          });
          return d.promise;
        },
        flattenModel: function(model) {
          var k, rv, v;
          rv = {};
          for (k in model) {
            v = model[k];
            if (angular.isArray(v)) {
              rv[k] = v.map(function(e) {
                return e.id;
              });
            } else {
              rv[k] = v;
            }
          }
          return rv;
        }
      };
      spinc.subscribers['OBJECT_UPDATE'] = [
        function(obj) {
          var k, o, prop, results, subscribers, v, val;
          subscribers = spinc.objsubscribers[obj.id] || [];
          results = [];
          for (k in subscribers) {
            v = subscribers[k];
            if (!spinc.objects[obj.id]) {
              spinc.objects[obj.id] = obj;
            } else {
              o = spinc.objects[obj.id];
              for (prop in obj) {
                val = obj[prop];
                o[prop] = val;
              }
            }
            results.push(v(obj));
          }
          return results;
        }
      ];
      return spinc;
    };
  })(this));

}).call(this);

//# sourceMappingURL=spinclient.js.map
